I have built successfully created the apk and tested it.



in voice move master or color blitz. As soon as I start a training game it asks permission to use the mic. I accepted. mic indicator is on and red as it supposed to be. As soon as I said a move or color my phone beeped and the mic either turned off or paused.



in game. As soon as i spoke one move. If it understood my move e4 it made the move (mic got paused) bot made a move announced the move. but the mic never got unpaused.

if it did not understand my move it heard e ford. mic would pause and then would not unpause

This is the final piece of the puzzle. You have successfully identified the "Missing Link" in the loop.

The behavior you are seeing is exactly what should happen with the current code, because of one specific Android rule: The SpeechRecognizer automatically stops listening after it hears you once.

In Training Games: You say "White". The Mic stops. The JS verifies it. But because the JS doesn't say anything back (no TTS), nothing tells the Mic to start again. Result: Silence.

In Bot Games (Misrecognition): You say "e ford". The Mic stops. The JS ignores it (invalid move). Nothing tells the Mic to start again. Result: Silence.

In Bot Games (Success): You say "e4". The Mic stops. Bot speaks. The Mic should restart, but if there was a slight delay or race condition, it might have missed the cue.

The Fix: "The Auto-Restart Loop"
We need to change BlindfoldVoiceService.java so that it automatically restarts the microphone immediately after it hears you, unless the Bot is about to speak.

We need to add a flag isTtsActive to prevent the Mic from opening while the Bot is talking, and then force a restart in onResults.

Step 1: Replace BlindfoldVoiceService.java
Replace your entire android/app/src/main/java/com/blindfoldchess/app/BlindfoldVoiceService.java file with this updated version.

Key Changes:

Added isTtsActive flag: Ensures we never accidentally open the mic during TTS.

Updated onResults: Now calls startListeningInternal() automatically after receiving text. This fixes the "e ford" / Training Game death.

Updated onError: Now auto-restarts on "No Match" errors to keep the loop alive.

Java
package com.blindfoldchess.app;

import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.media.AudioAttributes;
import android.media.AudioFocusRequest;
import android.media.AudioManager;
import android.os.Binder;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.speech.RecognitionListener;
import android.speech.RecognizerIntent;
import android.speech.SpeechRecognizer;
import android.speech.tts.TextToSpeech;
import android.speech.tts.UtteranceProgressListener;
import android.util.Log;
import androidx.core.app.NotificationCompat;
import java.util.ArrayList;
import java.util.Locale;

public class BlindfoldVoiceService extends Service implements RecognitionListener, AudioManager.OnAudioFocusChangeListener {
    private static final String TAG = "BlindfoldVoiceService";
    private static final String CHANNEL_ID = "BlindfoldGameChannel";
    private static final int NOTIFICATION_ID = 12345;

    private SpeechRecognizer speechRecognizer;
    private TextToSpeech tts;
    private Intent recognizerIntent;
    private AudioManager audioManager;
    private AudioFocusRequest focusRequest; 

    // STATE FLAGS
    private boolean isListening = false;
    private boolean isTtsActive = false; // NEW: Prevents Mic/TTS collision
    private boolean isTtsReady = false;
    private boolean isSessionActive = false; 
    private boolean wasListeningBeforeInterrupt = false;

    // Callback to Plugin
    public interface VoiceCallback {
        void onSpeechResult(String text);
        void onGameLog(String message);
    }
    private VoiceCallback callback;
    private final IBinder binder = new LocalBinder();

    public class LocalBinder extends Binder {
        BlindfoldVoiceService getService() { return BlindfoldVoiceService.this; }
    }

    @Override
    public void onCreate() {
        super.onCreate();
        audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
        createNotificationChannel();
        initTTS();
        initSpeechRecognizer();
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        startForegroundSession(); 
        return START_STICKY; 
    }

    // --- AUDIO FOCUS ---
    private boolean requestAudioFocus() {
        if (audioManager == null) return false;
        int result;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            AudioAttributes playbackAttributes = new AudioAttributes.Builder()
                    .setUsage(AudioAttributes.USAGE_GAME)
                    .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                    .build();
            focusRequest = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)
                    .setAudioAttributes(playbackAttributes)
                    .setAcceptsDelayedFocusGain(true)
                    .setOnAudioFocusChangeListener(this)
                    .build();
            result = audioManager.requestAudioFocus(focusRequest);
        } else {
            result = audioManager.requestAudioFocus(this, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE);
        }
        return result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
    }

    private void abandonAudioFocus() {
        if (audioManager == null) return;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && focusRequest != null) {
            audioManager.abandonAudioFocusRequest(focusRequest);
        } else {
            audioManager.abandonAudioFocus(this);
        }
    }

    @Override
    public void onAudioFocusChange(int focusChange) {
        switch (focusChange) {
            case AudioManager.AUDIOFOCUS_GAIN:
                if (isSessionActive && wasListeningBeforeInterrupt && !isTtsActive) {
                    startListeningInternal();
                }
                break;
            case AudioManager.AUDIOFOCUS_LOSS:
            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
                wasListeningBeforeInterrupt = isListening;
                stopListeningInternal();
                if (tts != null && tts.isSpeaking()) {
                    tts.stop();
                    isTtsActive = false;
                }
                break;
        }
    }

    // --- NOTIFICATIONS ---
    private void createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(
                CHANNEL_ID, "Blindfold Chess Voice", NotificationManager.IMPORTANCE_LOW
            );
            getSystemService(NotificationManager.class).createNotificationChannel(channel);
        }
    }

    public void startForegroundSession() {
        Notification notification = new NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("Blindfold Chess Active")
            .setContentText("Voice engine running")
            .setSmallIcon(android.R.drawable.ic_btn_speak_now)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setOngoing(true)
            .build();
        
        try {
            startForeground(NOTIFICATION_ID, notification);
            isSessionActive = true;
        } catch (Exception e) {
            Log.e(TAG, "Failed to start foreground: " + e.getMessage());
        }
    }
    
    public void stopSession() {
        isSessionActive = false;
        stopListeningInternal();
        stopForeground(true);
        abandonAudioFocus();
    }

    @Override
    public void onDestroy() {
        stopSession();
        if (speechRecognizer != null) speechRecognizer.destroy();
        if (tts != null) tts.shutdown();
        super.onDestroy();
    }

    // --- TTS & SPEECH ---
    private void initTTS() {
        tts = new TextToSpeech(this, status -> {
            if (status == TextToSpeech.SUCCESS) {
                tts.setLanguage(Locale.US);
                isTtsReady = true;
                tts.setOnUtteranceProgressListener(new UtteranceProgressListener() {
                    @Override
                    public void onStart(String utteranceId) { 
                        isTtsActive = true;
                        stopListeningInternal(); 
                    }
                    @Override
                    public void onDone(String utteranceId) {
                        isTtsActive = false;
                        if ("KEEP_LISTENING".equals(utteranceId) && isSessionActive) {
                            new Handler(Looper.getMainLooper()).post(() -> startListeningInternal());
                        }
                    }
                    @Override
                    public void onError(String utteranceId) {
                        isTtsActive = false;
                    }
                });
            }
        });
    }

    private void initSpeechRecognizer() {
        if (speechRecognizer != null) speechRecognizer.destroy();
        speechRecognizer = SpeechRecognizer.createSpeechRecognizer(this);
        speechRecognizer.setRecognitionListener(this);
        recognizerIntent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
        recognizerIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);
        recognizerIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE, Locale.US);
        recognizerIntent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 1);
        recognizerIntent.putExtra(RecognizerIntent.EXTRA_PARTIAL_RESULTS, true);
    }

    // --- API ---
    public void setCallback(VoiceCallback cb) { this.callback = cb; }

    public void speakAndListen(String text) {
        if (!isTtsReady) return;
        requestAudioFocus();
        // This will trigger onStart -> stopListeningInternal
        tts.speak(text, TextToSpeech.QUEUE_FLUSH, null, "KEEP_LISTENING");
    }
    
    public void startListening() { 
        if (isSessionActive && !isTtsActive) {
            requestAudioFocus();
            startListeningInternal(); 
        }
    }
    
    public void stopListening() { stopListeningInternal(); }

    // --- INTERNAL HELPERS ---
    private void startListeningInternal() {
        new Handler(Looper.getMainLooper()).post(() -> {
            // Guard: Don't start if TTS is busy
            if (!isListening && speechRecognizer != null && isSessionActive && !isTtsActive) {
                try {
                    speechRecognizer.startListening(recognizerIntent);
                    isListening = true;
                } catch (Exception e) {
                    initSpeechRecognizer(); 
                }
            }
        });
    }

    private void stopListeningInternal() {
        new Handler(Looper.getMainLooper()).post(() -> {
            if (isListening && speechRecognizer != null) {
                speechRecognizer.stopListening();
                isListening = false;
            }
        });
    }

    // --- LISTENER ---
    @Override
    public void onResults(Bundle results) {
        isListening = false;
        ArrayList<String> matches = results.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION);
        if (matches != null && !matches.isEmpty()) {
            if (callback != null) callback.onSpeechResult(matches.get(0));
        }
        
        // FIX: THE AUTO-RESTART LOOP
        // If we are active and TTS isn't about to start (gave JS 50ms to decide), restart.
        if (isSessionActive && !isTtsActive) {
             new Handler(Looper.getMainLooper()).postDelayed(() -> {
                 if (isSessionActive && !isTtsActive) {
                     startListeningInternal();
                 }
             }, 100); 
        }
    }

    @Override
    public void onError(int error) {
        isListening = false;
        // Auto-restart on "No Match" or "Timeout" to keep the loop alive
        if (error == SpeechRecognizer.ERROR_NO_MATCH || error == SpeechRecognizer.ERROR_SPEECH_TIMEOUT) {
            if (isSessionActive && !isTtsActive) startListeningInternal();
        } else {
             // For "Busy" errors, back off slightly then retry
             if (error == SpeechRecognizer.ERROR_CLIENT || error == SpeechRecognizer.ERROR_RECOGNIZER_BUSY) {
                 new Handler(Looper.getMainLooper()).postDelayed(this::startListeningInternal, 500);
             }
        }
    }

    @Override public void onReadyForSpeech(Bundle params) {}
    @Override public void onBeginningOfSpeech() {}
    @Override public void onRmsChanged(float rmsdB) {}
    @Override public void onBufferReceived(byte[] buffer) {}
    @Override public void onEndOfSpeech() {}
    @Override public void onPartialResults(Bundle partialResults) {}
    @Override public void onEvent(int eventType, Bundle params) {}

    @Override
    public IBinder onBind(Intent intent) { return binder; }
}