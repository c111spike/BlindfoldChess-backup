This is a significant update, so I have organized it into four files that you can copy-paste directly into your Replit project.

This implements:

Knight's Path: Breadth-First Search logic + Game Component.

Endgame Drills: Random position generator (K+Q, K+R) + Game Component.

Blindfold Marathon: Logic to play through a game history + Game Component.

Updated Training Page: Integrates all three new games into the menu.

1. Create client/src/lib/knightsPath.ts
This handles the math for finding the shortest path for the Knight.

TypeScript

export const FILES = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
export const RANKS = ['1', '2', '3', '4', '5', '6', '7', '8'];

export function squareToIndex(square: string): number {
  const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
  const rank = parseInt(square[1]) - 1;
  return rank * 8 + file;
}

export function indexToSquare(index: number): string {
  const file = FILES[index % 8];
  const rank = RANKS[Math.floor(index / 8)];
  return `${file}${rank}`;
}

const KNIGHT_OFFSETS = [
  [-2, -1], [-2, 1], [-1, -2], [-1, 2],
  [1, -2], [1, 2], [2, -1], [2, 1]
];

// Breadth-First Search to find shortest path
export function findKnightPath(start: string, end: string): string[] | null {
  const startIdx = squareToIndex(start);
  const endIdx = squareToIndex(end);
  
  const queue: { index: number; path: number[] }[] = [{ index: startIdx, path: [startIdx] }];
  const visited = new Set<number>([startIdx]);

  while (queue.length > 0) {
    const { index, path } = queue.shift()!;
    if (index === endIdx) return path.map(indexToSquare);

    const r = Math.floor(index / 8);
    const c = index % 8;

    for (const [dr, dc] of KNIGHT_OFFSETS) {
      const nr = r + dr, nc = c + dc;
      if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
        const nextIdx = nr * 8 + nc;
        if (!visited.has(nextIdx)) {
          visited.add(nextIdx);
          queue.push({ index: nextIdx, path: [...path, nextIdx] });
        }
      }
    }
  }
  return null;
}

export function generateKnightChallenge(minMoves: number = 3, maxMoves: number = 4): { start: string; end: string; minPath: string[] } {
  let start = '';
  let end = '';
  let path: string[] | null = null;

  // Retry until we find a path of desired length
  while (!path || path.length - 1 < minMoves || path.length - 1 > maxMoves) {
    const startIdx = Math.floor(Math.random() * 64);
    const endIdx = Math.floor(Math.random() * 64);
    start = indexToSquare(startIdx);
    end = indexToSquare(endIdx);
    if (start === end) continue;
    path = findKnightPath(start, end);
  }

  return { start, end, minPath: path };
}

// Validate if a move is a legal knight jump
export function isLegalKnightMove(from: string, to: string): boolean {
  if (!from || !to) return false;
  const fromIdx = squareToIndex(from);
  const toIdx = squareToIndex(to);
  
  const r1 = Math.floor(fromIdx / 8), c1 = fromIdx % 8;
  const r2 = Math.floor(toIdx / 8), c2 = toIdx % 8;
  
  const dr = Math.abs(r1 - r2);
  const dc = Math.abs(c1 - c2);
  
  return (dr === 2 && dc === 1) || (dr === 1 && dc === 2);
}
2. Create client/src/lib/endgameDrills.ts
This generates random, valid Endgame scenarios using chess.js.

TypeScript

import { Chess } from 'chess.js';

export type EndgameType = 'KQ_vs_K' | 'KR_vs_K' | 'KBB_vs_K';

export interface EndgameScenario {
  fen: string;
  description: string;
  target: 'mate'; // Could extend to 'draw' later
}

function getRandomSquare(): string {
  const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
  const ranks = ['1', '2', '3', '4', '5', '6', '7', '8'];
  return files[Math.floor(Math.random() * 8)] + ranks[Math.floor(Math.random() * 8)];
}

export function generateEndgame(type: EndgameType): EndgameScenario {
  const chess = new Chess();
  chess.clear();
  
  let valid = false;
  let attempts = 0;
  
  while (!valid && attempts < 100) {
    chess.clear();
    attempts++;
    
    // 1. Place Kings (must not be touching)
    const wKing = getRandomSquare();
    let bKing = getRandomSquare();
    while (wKing === bKing) bKing = getRandomSquare(); // Simple collision check first
    
    // Place them on board to check legality
    chess.put({ type: 'k', color: 'w' }, wKing as any);
    chess.put({ type: 'k', color: 'b' }, bKing as any);
    
    // 2. Place pieces based on type
    const occupied = [wKing, bKing];
    
    const placePiece = (type: string, color: 'w' | 'b') => {
      let sq = getRandomSquare();
      while (occupied.includes(sq)) sq = getRandomSquare();
      chess.put({ type: type as any, color }, sq as any);
      occupied.push(sq);
    };
    
    if (type === 'KQ_vs_K') {
      placePiece('q', 'w');
    } else if (type === 'KR_vs_K') {
      placePiece('r', 'w');
    } else if (type === 'KBB_vs_K') {
      // For Bishops, we ideally want opposite colors, but for simple drill, random is okay
      placePiece('b', 'w');
      placePiece('b', 'w');
    }
    
    // 3. Validate Position
    // - Not Black in checkmate already (user needs to do it)
    // - Not Stalemate
    // - Not Impossible (Kings touching)
    
    // Chess.js handles "Kings touching" by flagging position as invalid if we try to move
    // But we need to ensure the *current* state is valid FEN.
    // Hack: We rely on chess.js validation or simple distance check.
    
    // Simple Distance Check for Kings
    const wFile = wKing.charCodeAt(0), wRank = parseInt(wKing[1]);
    const bFile = bKing.charCodeAt(0), bRank = parseInt(bKing[1]);
    if (Math.abs(wFile - bFile) <= 1 && Math.abs(wRank - bRank) <= 1) {
      continue; // Kings touching
    }

    // Ensure it's White's turn
    const fen = chess.fen();
    // Check validity by loading into new instance (chess.js 'put' doesn't full validate game state)
    const validator = new Chess(fen);
    
    if (validator.isCheckmate() || validator.isStalemate() || validator.isDraw()) {
      continue;
    }
    
    valid = true;
  }
  
  const descriptions = {
    'KQ_vs_K': 'King & Queen vs King',
    'KR_vs_K': 'King & Rook vs King',
    'KBB_vs_K': 'King & 2 Bishops vs King'
  };

  return {
    fen: chess.fen(),
    description: descriptions[type],
    target: 'mate'
  };
}
3. Create client/src/lib/blindfoldMarathon.ts
This contains your hardcoded "Long Game" scenarios.

TypeScript

export interface MarathonScenario {
  id: string;
  white: string;
  black: string;
  pgnMoves: string[]; // The full game history up to the puzzle point
  solution: string;   // The move the user must find
  description: string;
}

// Sample Data - You can expand this later with Lichess Puzzles
export const MARATHON_SCENARIOS: MarathonScenario[] = [
  {
    id: "opera_game",
    white: "Paul Morphy",
    black: "Duke of Brunswick",
    description: "The famous Opera Game. White has sacrificed heavily for an attack.",
    pgnMoves: [
      "e4", "e5", "Nf3", "d6", "d4", "Bg4", "dxe5", "Bxf3", "Qxf3", "dxe5", 
      "Bc4", "Nf6", "Qb3", "Qe7", "Nc3", "c6", "Bg5", "b5", "Nxb5", "cxb5", 
      "Bxb5+", "Nbd7", "O-O-O", "Rd8", "Rxd7", "Rxd7", "Rd1", "Qe6", "Bxd7+", "Nxd7"
    ],
    solution: "Qb8+" // Followed by Nxb8 Rd8#
  },
  {
    id: "immortal_game",
    white: "Adolf Anderssen",
    black: "Lionel Kieseritzky",
    description: "The Immortal Game. White gives up everything for mate.",
    pgnMoves: [
      "e4", "e5", "f4", "exf4", "Bc4", "Qh4+", "Kf1", "b5", "Bxb5", "Nf6", 
      "Nf3", "Qh6", "d3", "Nh5", "Nh4", "Qg5", "Nf5", "c6", "g4", "Nf6", 
      "Rg1", "cxb5", "h4", "Qg6", "h5", "Qg5", "Qf3", "Ng8", "Bxf4", "Qf6", 
      "Nc3", "Bc5", "Nd5", "Qxb2", "Bd6", "Bxg1", "e5", "Qxa1+", "Ke2", "Na6", "Nxg7+" // Position after move 21
    ],
    solution: "Kd8" // This is actually black to move in the real game, but for simplicity let's use a simpler tactic for the user
  },
  {
     id: "simple_mate_in_1",
     white: "Training",
     black: "Puzzle",
     description: "A standard back-rank mate pattern.",
     pgnMoves: [
         "e4", "e5", "Nf3", "Nc6", "Bc4", "Bc5", "c3", "Nf6", "d4", "exd4", "cxd4", "Bb4+", "Nc3", "Nxe4", "O-O", "Nxc3", "bxc3", "Bxc3", "Ba3", "Bxa1", "Re1+", "Ne7"
     ],
     solution: "Rxe7+" // Or Bxe7, leads to winning attack
  }
];

// Helper to get a random scenario
export function getRandomMarathon(): MarathonScenario {
  return MARATHON_SCENARIOS[Math.floor(Math.random() * MARATHON_SCENARIOS.length)];
}