üõ†Ô∏è The "Continuous Loop" Architecture (Iteration 29)
Here is how we refine your proposed plan to make it bulletproof for the S9+.

1. The Auto-Restart Loop (onResult)
You are right: relying on setMute to handle the flow was a mistake if the hardware is turning itself off.

New Logic: In the onResult handler (or onEndOfSpeech event), we process the text and then immediately trigger start() again.

The Flag: We add shouldRestart.

Normal: true. The loop continues indefinitely.

Bot Speaking: false. We break the loop so the mic stays off while the bot talks.

2. Handling the Bot's Turn (The "Pause" Button)
We don't need "Mute" anymore. We need a "Pause Loop."

Before TTS: Set shouldRestart = false. If the mic is currently running, we leave it alone (it will die naturally on the next result or we can force kill it).

After TTS: Set shouldRestart = true and manually call start() to kickstart the loop again.

3. Synchronous Unmute
Removing the 400ms delay is safe if we are using this Start/Stop logic because the "Beep" of the hardware starting acts as its own buffer.

üìÇ Surgical Implementation Plan
Here is the exact code logic for voice.ts and game.tsx.

Part 1: The Wrapper (voice.ts)
We turn the wrapper into a "Persisted Looper."

TypeScript

// Inside VoiceRecognitionWrapper
private shouldRestart: boolean = true;
private isRunning: boolean = false;

async start() {
  this.shouldRestart = true;
  if (!this.isRunning) {
    this.isRunning = true;
    await voiceMaster.start(); // This is the raw hardware call
  }
}

// Crucial: The Loop Engine
onResult(transcript: string) {
  // 1. Process the move
  this.processMove(transcript);
  
  // 2. The Auto-Restart (The "Pulse")
  if (this.shouldRestart) {
    console.log("[Voice] Auto-restarting session...");
    // We don't wait for stop; we just request start. 
    // The plugin usually handles the transition, or we can force a quick cycle.
    voiceMaster.start(); 
  } else {
    this.isRunning = false; // Loop broken for TTS
  }
}

// Logic to pause the loop for TTS
pauseLoop() {
  this.shouldRestart = false;
  this.stop(); // Kill current listener so it doesn't interrupt TTS
  this.isRunning = false;
}

// Logic to resume the loop after TTS
resumeLoop() {
  this.shouldRestart = true;
  this.start(); // Kickstart the cycle again
}
Part 2: The Game Logic (game.tsx)
We replace the "Mute" calls with "Loop Control" calls.

TypeScript

// Inside handleBotMove
pauseLoop(); // Stop listening immediately
await speak(botMovePhonetic);
resumeLoop(); // Restart the listening loop
üöÄ Why this fixes your issues
Fixes "1-Move Limit": The mic died after move 1 because the OS killed it. Now, resumeLoop() explicitly wakes it up.

Fixes "Training Pause": Since Training Mode rarely has long TTS blocks, shouldRestart stays true, so the mic just keeps cycling instantly after every answer.

Fixes "Reconstruction": Since the loop is manual, when the game ends, we just call pauseLoop(), and then Reconstruction calls start() to begin its own fresh loop.