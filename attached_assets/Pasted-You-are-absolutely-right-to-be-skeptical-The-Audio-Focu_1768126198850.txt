You are absolutely right to be skeptical. The "Audio Focus War" is a classic Android nightmare, and you have correctly identified that AUDIOFOCUS_GAIN_TRANSIENT from TTS will absolutely kill the SpeechRecognizer on the OS level, often triggering ERROR_CLIENT (busy) or ERROR_RECOGNIZER_BUSY.

However, the beauty of the fix we are about to apply is that it solves both problems simultaneously.

Race Condition: By forcing scheduleRestart to use triggerRestart() (the Gatekeeper), we ensure we never have two start commands flying at once.

Audio Focus (The Logic Fix): Crucially, triggerRestart() checks the this.shouldRestart flag. Your speak() function sets shouldRestart = false (via pauseLoop) before TTS starts.

Old Code: scheduleRestart called startNative() directly, ignoring shouldRestart and blindly trying to fight the TTS for the mic.

New Code: scheduleRestart calls triggerRestart(), which checks shouldRestart, sees it is false (because TTS is active), and gracefully aborts.

This means we don't just stop the race condition; we also stop the "Zombie" form attempting to interrupt the TTS.

Here is the applied fix for client/src/lib/voice.ts.

The Fix: client/src/lib/voice.ts
I am patching the VoiceMasterEngine class to implement the "Gatekeeper" pattern and the isStarting guard.

TypeScript

// ... (Previous imports and interfaces remain the same)

class VoiceMasterEngine {
  // ... (Existing properties)
  
  // ADD THIS: Guard against re-entrant start calls
  private isStarting: boolean = false;

  // ... (checkAvailability, setOnMicBusyChange, mute, setMute, getIsMuted remain same)

  /**
   * GOLD STANDARD: The "Mutex" Restart Logic (FIRE-AND-FORGET)
   * ... (No changes to triggerRestart logic needed, but ensure it matches this structure)
   */
  private triggerRestart(): void {
    if (this.restartPromise) {
      console.log('[VoiceMaster] Restart already in progress, skipping duplicate.');
      return;
    }

    this.restartPromise = (async () => {
      try {
        console.log('[VoiceMaster] Serialized restart sequence initiating...');
        
        try {
          await CapacitorSpeechRecognition.stop();
        } catch (e) { /* expected */ }

        await new Promise(resolve => setTimeout(resolve, 50));

        // CHECK: This guard is what protects us from AudioFocus wars!
        if (this.shouldRestart && !this.micBusy) {
          try {
            await this.startNative();
          } catch (startErr) {
            console.warn('[VoiceMaster] triggerRestart start failed, scheduling retry');
            setTimeout(() => {
              if (this.shouldRestart && !this.micBusy && !this.restartPromise) {
                this.triggerRestart();
              }
            }, 200);
          }
        }
      } catch (err) {
        // ... error handling
      } finally {
        this.restartPromise = null;
      }
    })();
  }

  // ... (pauseLoop, resumeLoop, getShouldRestartLoop, start, setLegalMoves, processTranscript... remain same)

  // UPDATED: startNative with isStarting Guard
  private async startNative(): Promise<boolean> {
    // 1. GUARD: Prevent UI and Background Loop collision
    if (this.isStarting) {
      console.log('[VoiceMaster] startNative blocked: Already starting');
      return false;
    }

    if (this.micBusy) {
      console.log('[VoiceMaster] Mic is busy, not starting');
      return false;
    }
    
    // ... (Lockout logic remains same) ...
    const timeSinceLastError = Date.now() - this.lastErrorTime;
    if (timeSinceLastError < 3000 && this.lastErrorTime > 0) {
      // ... existing lockout logic
      if (!this.restartTimeout) this.scheduleRestart();
      return true;
    }
    
    this.isStarting = true; // LOCK

    try {
      if (this.listenerHandle) {
        await this.listenerHandle.remove();
        this.listenerHandle = null;
      }
      
      this.listenerHandle = await CapacitorSpeechRecognition.addListener('partialResults', (data: { matches: string[] }) => {
        if (!this.shouldRestart) return;
        if (data.matches && data.matches.length > 0 && this.shouldBeListening) {
          this.consecutiveFailures = 0;
          this.processTranscript(data.matches[0]);
          if (this.shouldRestart) this.triggerRestart();
        }
      });
      
      // ... (stateListenerHandle logic remains same) ...
      this.stateListenerHandle = await CapacitorSpeechRecognition.addListener('listeningState', (state: { status: string }) => {
         // ... (existing logic)
         if (state.status === 'stopped' && this.shouldBeListening && this.shouldRestart && !this.micBusy) {
             this.triggerRestart();
         }
      });
      
      await CapacitorSpeechRecognition.start({
        language: 'en-US',
        partialResults: true,
        popup: false,
      });
      
      this.isListening = true;
      this.consecutiveFailures = 0;
      return true;
    } catch (e) {
      console.error('[VoiceMaster] Failed to start native:', e);
      this.lastErrorTime = Date.now();
      this.consecutiveFailures++;
      
      if (this.consecutiveFailures >= VoiceMasterEngine.MAX_CONSECUTIVE_FAILURES) {
        this.micBusy = true;
        this.isListening = false;
        if (this.onMicBusyChange) this.onMicBusyChange(true);
        if (this.onRetryNeeded) this.onRetryNeeded();
        return false;
      }
      
      if (this.shouldBeListening) {
        this.scheduleRestart();
      }
      return false;
    } finally {
      this.isStarting = false; // UNLOCK
    }
  }

  // UPDATED: scheduleRestart to use Gatekeeper
  private scheduleRestart(): void {
    const timeSinceLastError = Date.now() - this.lastErrorTime;
    
    // ... (Lockout logic remains same)
    
    if (this.micBusy) return;
    
    if (this.restartTimeout) clearTimeout(this.restartTimeout);
    
    this.restartTimeout = setTimeout(() => {
      if (this.shouldBeListening && !this.micBusy) {
        console.log('[VoiceMaster] Scheduled restart firing via Gatekeeper');
        
        if (isNative) {
          // FIX: Use triggerRestart() so we respect 'shouldRestart' (TTS flag) and the Mutex
          this.triggerRestart();
        } else {
          this.startWeb();
        }
      }
    }, 500);
  }

  // ... (rest of class remains same)
}
Plan B: If Audio Focus Persists
If this fix stabilizes the loop but you still hear the "beep-boop" of the mic fighting TTS, or if the mic simply never comes back after TTS, you are hitting the OS-level preemption you feared.

Since you are using Capacitor, you can solve this in MainActivity.java by managing the Audio Focus manually, but it is tricky with plugins. A cleaner "Nuclear Option" if the above TS fix fails is to force the TTS to use the ALARM or RING stream (which mixes with other audio) instead of the MUSIC stream (which requests exclusive focus).

However, the Capacitor TTS plugin usually doesn't expose stream selection. If needed, we can implement a simple Native Bridge method in MainActivity.java to request "Transient Audio Focus with Ducking" manually before startNative is called, essentially "reserving" the spot for the mic.