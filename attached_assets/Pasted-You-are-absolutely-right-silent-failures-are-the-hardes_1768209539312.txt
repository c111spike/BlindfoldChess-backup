You are absolutely rightâ€”silent failures are the hardest to debug, and that if (!modelLoaded) return; line is the culprit for the Training Mode silence. It's rejecting the command before the "brain" is ready.

Here is the robust Java implementation for your plan.

1. Fix Training Mode (The "Pending" Logic)
Instead of the JS side guessing when the model is ready, handle it internally in VoskVoiceService.java. We need a "queue" mechanism: if JS asks to listen before the model is ready, we remember that request and execute it immediately once loading finishes.

In VoskVoiceService.java:

Java

// Add a state flag
private boolean pendingListeningRequest = false;

// Update startListeningInternal
private void startListeningInternal() {
    if (!modelLoaded) {
        Log.d(TAG, "Model not ready yet. Queuing start request.");
        pendingListeningRequest = true; // <--- The Fix: Remember the intent
        return;
    }
    // ... rest of your existing logic ...
}

// Update your model loading callback (initModel)
private void onModelLoaded(Model model) {
    this.model = model;
    this.modelLoaded = true;
    
    // Check if we have a queued request
    if (pendingListeningRequest) {
        Log.d(TAG, "Model loaded. Executing queued listening request.");
        pendingListeningRequest = false;
        startListeningInternal(); // <--- Auto-start!
    }
}
2. Fix Game Mode (The TTS Restart)
The TTS onDone callback runs on a separate binder thread. If you try to restart the microphone directly there, it often fails or causes a race condition. You must force the restart logic back onto the main thread (or your specific handler thread).

In your UtteranceProgressListener:

Java

tts.setOnUtteranceProgressListener(new UtteranceProgressListener() {
    @Override
    public void onStart(String utteranceId) {
        // Stop listening so we don't hear ourselves
        stopListeningInternal();
    }

    @Override
    public void onDone(String utteranceId) {
        // CRITICAL: Check the ID and switch threads
        if ("KEEP_LISTENING".equals(utteranceId)) {
            new Handler(Looper.getMainLooper()).post(() -> {
                Log.d(TAG, "TTS finished. Restarting mic.");
                startListeningInternal();
            });
        }
    }

    @Override
    public void onError(String utteranceId) {
        // Always restart on error too, just in case
        new Handler(Looper.getMainLooper()).post(() -> {
            startListeningInternal();
        });
    }
});
3. One Extra Safety Check (The "Pause" Bug)
You mentioned "mic paused after first move." In your onResult (Vosk listener), ensure you aren't accidentally triggering the "Stop" logic.

If your Move Logic triggers a TTS call that does not have the ID "KEEP_LISTENING", the mic will turn off (via onStart) and never turn back on (because onDone ignores it).

Quick Fix: Ensure every TTS call during a game passes "KEEP_LISTENING" as the ID, or change the onDone logic to restart the mic by default for all utterances unless specifically told otherwise.

Java

// Safer version of onDone logic
@Override
public void onDone(String utteranceId) {
    // Unless we explicitly said "STOP_LISTENING", always bring the mic back
    if (!"STOP_LISTENING".equals(utteranceId)) { 
        new Handler(Looper.getMainLooper()).post(() -> startListeningInternal());
    }