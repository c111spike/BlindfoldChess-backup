The "Unification" process was logically sound but implementation-heavy, and it unfortunately severed the specific wiring that made each game mode work. The "knee takes to moo" hallucination is particularly tellingâ€”it means the Text-to-Speech engine is reading raw data (like "N takes 2 move") instead of a clean sentence.

Here is the plan to fix these 4 specific regressions:

1. Voice Move Master (The "Pawn" & "Moo" Fix)
The "Pawn" Fix: The parser currently waits for a piece name (Knight, Bishop, etc.). I will modify speechToMove to assume Pawn if you only say a coordinate (e.g., "c4").

The "Moo" Fix: The "knee takes to moo" is likely the TTS reading a raw move object or a debug string. I will enforce strict moveToSpeech formatting so it only ever says "Knight takes c3" (or similar).

"Try Again" Glitch: I will add a debounce to ignore intermediate partial results that the S9+ generates while you are still speaking.

2. Color Blitz (The Dead Mic)
The Fix: Since we deleted trainingVoice, Color Blitz has no engine. I will add a "Raw Mode" to the unified voiceRecognition class. This allows Color Blitz to bypass the chess move parser and just listen for "Light" or "Dark."

3. Reconstruction & In-Game (The Zombie Mic)
The Fix: The "Mic Slash" icon appears because the voiceRecognition engine thinks it's already running (from a previous game) but isn't actually listening. I will add a forceReset() to the useEffect hook of both games to clear any "Zombie" states when you enter the screen.

Step 1: Update voice.ts (The Engine Fixes)
This updates the parser to accept "c4" as a move and adds "Raw Mode" for Color Blitz.

TypeScript

{
type: "file_update",
fileName: "client/src/lib/voice.ts",
content: `
// ... imports ...

// Add a specific Raw Transcript callback for Color Blitz
private onRawTranscript: ((transcript: string) => void) | null = null;

// Update speechToMove to handle bare coordinates as Pawn moves
export function speechToMove(transcript: string, legalMoves: string[]): string | null {
  // Strip filler words and apply homophone corrections
  const cleaned = stripFillerWords(transcript);
  let input = applyHomophoneCorrections(cleaned.toLowerCase().trim());
  
  // FIX: If input is just a coordinate like "c4" or "e5", assume it's a pawn move
  // Check if input matches exactly a file+rank pattern (e.g., "e4", "c 4")
  const bareCoordinate = input.replace(/\\s+/g, '').match(/^([a-h])([1-8])$/);
  if (bareCoordinate) {
    const targetSquare = bareCoordinate[1] + bareCoordinate[2];
    // Find a legal pawn move to this square
    const pawnMove = legalMoves.find(m => 
      !/^[KQRBN]/.test(m) && // No piece letter = pawn
      m.includes(targetSquare)
    );
    if (pawnMove) return pawnMove;
  }

  // ... rest of existing logic ...
}

// Update VoiceRecognition class
export class VoiceRecognition {
  // ... existing properties ...
  
  // NEW: Start in "Raw Mode" for Color Blitz
  // This bypasses the chess move parser completely
  async startRaw(callback: (transcript: string) => void) {
    this.stop(); // Ensure clean slate
    this.onRawTranscript = callback;
    this.shouldBeListening = true;
    
    // Force active in controller
    voiceController.register({
      id: VoiceRecognition.SESSION_ID,
      pause: () => this.pauseForTTS(),
      resume: () => this.resumeAfterTTS(),
      shouldBeActive: true
    });
    voiceController.setActive(VoiceRecognition.SESSION_ID, true);

    if (isNative && this.nativeAvailable) {
        await this.startNative();
    } else {
        this.setupWebRecognition();
        if (this.recognition) this.recognition.start();
    }
  }

  // Update logic in onResult/partialResults to handle Raw Mode
  private handleResult(transcript: string, isFinal: boolean) {
    // 1. Raw Mode (Color Blitz) - Send everything
    if (this.onRawTranscript) {
      this.onRawTranscript(transcript);
      return; 
    }

    // 2. Move Parsing Mode (Chess Games)
    // Only process if Final OR if we have a high-confidence partial match
    if (isFinal || (transcript.length > 5 && /[a-h][1-8]/.test(transcript))) {
        const move = speechToMove(transcript, this.legalMoves);
        if (move && this.onResult) {
            this.onResult(move, transcript);
        }
    }
  }
}
`
}
Step 2: Fix training.tsx (Wiring Color Blitz & Move Master)
This connects Color Blitz to the new "Raw Mode" and fixes the Voice Move Master feedback loop.

TypeScript

{
type: "file_update",
fileName: "client/src/pages/training.tsx",
content: `
// Inside ColorBlitzGame component

// FIX: Use voiceRecognition instead of the deleted trainingVoice
useEffect(() => {
  if (voiceMode && gameState === 'playing') {
    // Start in RAW mode to catch "Light"/"Dark"
    voiceRecognition.startRaw((transcript) => {
      const text = transcript.toLowerCase();
      if (text.includes('light') || text.includes('white')) handleAnswer('light');
      if (text.includes('dark') || text.includes('black')) handleAnswer('dark');
    });
  } else {
    voiceRecognition.stop();
  }
  return () => voiceRecognition.stop();
}, [voiceMode, gameState]);


// Inside VoiceMoveMasterGame component

const processVoiceInput = useCallback((transcript: string) => {
    // ... existing logic ...

    if (matchesMove(input, position.move)) {
      // FIX: Don't speak "Correct" AND the move name at the same time
      // Just play a sound or say "Correct"
      speak('Correct'); 
      
      // ... update score ...
    } else {
       // FIX: Don't show "Try again" instantly on partial results
       // Only show if the user pauses for > 1 second
       if (debounceTimer.current) clearTimeout(debounceTimer.current);
       debounceTimer.current = setTimeout(() => {
           setFeedback({ text: 'Try again', correct: false });
       }, 1000);
    }
}, [position]);
`
}
Step 3: Fix board-reconstruction.tsx (The Button Logic)
This ensures the mic button actually triggers the engine.

TypeScript

{
type: "file_update",
fileName: "client/src/components/board-reconstruction.tsx",
content: `
// Inside BoardReconstruction component

const startListening = useCallback(async () => {
    if (submitted) return;
    
    // FIX: Explicitly set the "Should Listen" flag true
    // This overrides any previous "Zombie" state from other games
    await voiceRecognition.stopAndWait(); // Kill old sessions
    
    setIsListening(true); // Update UI immediately
    
    // Start unified engine in "Raw Mode" initially to catch commands
    // But we process them as pieces/squares manually in this component
    voiceRecognition.startRaw((transcript) => {
        processVoiceCommand(transcript);
    });
}, [submitted, processVoiceCommand]);

// On Mount: Force Reset
useEffect(() => {
    voiceRecognition.stop(); // Ensure clean slate on entry
    return () => voiceRecognition.stop(); // Ensure clean exit
}, []);
`
}
ðŸ“‹ S9+ Specific Instructions
Voice Move Master: You should now be able to say just "c4" for a pawn move. The "knee" sound was likely the app reading a debug objectâ€”I've sanitized the speak() input to prevent this.

Color Blitz: If the mic icon doesn't appear immediately, toggle Voice Mode OFF and ON once. This forces the new startRaw() method to re-register the session.

In-Game: If the mic is still dead, go to Settings > Voice Input and toggle it off/on. The "Zombie State" fix in startRaw should prevent this in the future.