Here is the final verified fix. This applies the "Ghost Buster" logic (to fix the training games turning off) AND removes the manual controls (to fix the Bot game collision).

Step 1: Apply the "Ghost Buster" & Gatekeeper to client/src/lib/voice.ts
TypeScript

//

// ... (Imports remain the same)

class VoiceMasterEngine {
  // ... (Keep existing properties)

  // 1. ADD: Guard against re-entrant start calls
  private isStarting: boolean = false;
  
  // 2. ADD: Ghost Buster Counter
  private expectedStops: number = 0;

  // ... (keep checkAvailability, setOnMicBusyChange, mute, setMute, getIsMuted)

  /**
   * GOLD STANDARD: The "Mutex" Restart Logic
   * Includes Ghost Buster to ignore self-inflicted stop events
   */
  private triggerRestart(): void {
    if (this.restartPromise) {
      console.log('[VoiceMaster] Restart already in progress, skipping duplicate.');
      return;
    }

    this.restartPromise = (async () => {
      try {
        console.log('[VoiceMaster] Serialized restart sequence initiating...');
        
        // GHOST BUSTER: We are stopping intentionally, ignore the event
        this.expectedStops++;
        
        try {
          await CapacitorSpeechRecognition.stop();
        } catch (e) {
          this.expectedStops = Math.max(0, this.expectedStops - 1);
        }

        // S9+ Buffer
        await new Promise(resolve => setTimeout(resolve, 100));

        if (this.shouldRestart && !this.micBusy) {
          try {
            await this.startNative();
          } catch (startErr) {
            console.warn('[VoiceMaster] triggerRestart start failed, scheduling retry');
            setTimeout(() => {
              if (this.shouldRestart && !this.micBusy && !this.restartPromise) {
                this.triggerRestart();
              }
            }, 200);
          }
        }
      } catch (err) {
        console.warn('[VoiceMaster] Restart sequence failed:', err);
      } finally {
        this.restartPromise = null;
      }
    })();
  }
  
  // 3. UPDATE: pauseInternal (Called by speak())
  private pauseInternal(): void {
    console.log(`[VoiceMaster] pauseInternal called`);
    this.shouldRestart = false; // Disable auto-restart loop
    
    if (!this.isListening) return;
    
    this.isPaused = true;
    if (isNative) {
      // We don't increment expectedStops here because pauseInternal sets shouldRestart=false,
      // so the state listener won't try to restart anyway.
      CapacitorSpeechRecognition.stop().catch(e => console.log(e));
    } else if (this.webRecognition) {
      this.webRecognition.stop();
    }
    this.isListening = false;
    if (this.config?.onListeningChange) this.config.onListeningChange(false);
  }
  
  // 4. UPDATE: resumeInternal (Called by speak() after delay)
  private async resumeInternal(): Promise<void> {
    console.log(`[VoiceMaster] resumeInternal called`);
    if (!this.shouldBeListening) return;
    if (this.isListening) return;
    
    this.isPaused = false;
    this.shouldRestart = true; // Re-enable auto-restart
    
    if (isNative) {
      this.triggerRestart(); // Use Gatekeeper
    } else {
      this.startWeb();
    }
  }

  // 5. UPDATE: startNative with Guards
  private async startNative(): Promise<boolean> {
    if (this.isStarting) {
      console.log('[VoiceMaster] startNative blocked: Already starting');
      return false;
    }
    if (this.micBusy) return false;
    
    // Lockout check
    const timeSinceLastError = Date.now() - this.lastErrorTime;
    if (timeSinceLastError < 3000 && this.lastErrorTime > 0) {
       if (!this.restartTimeout) this.scheduleRestart();
       return true;
    }
    
    this.isStarting = true; // LOCK

    try {
      if (this.listenerHandle) {
        await this.listenerHandle.remove();
        this.listenerHandle = null;
      }
      
      this.listenerHandle = await CapacitorSpeechRecognition.addListener('partialResults', (data: { matches: string[] }) => {
        if (!this.shouldRestart) return;
        if (data.matches && data.matches.length > 0 && this.shouldBeListening) {
          this.consecutiveFailures = 0;
          this.processTranscript(data.matches[0]);
          if (this.shouldRestart) this.triggerRestart(); // Hot Echo
        }
      });
      
      if (this.stateListenerHandle) {
        await this.stateListenerHandle.remove();
        this.stateListenerHandle = null;
      }
      
      this.stateListenerHandle = await CapacitorSpeechRecognition.addListener('listeningState', (state: { status: string }) => {
        if (state.status === 'stopped') {
          // GHOST BUSTER CHECK
          if (this.expectedStops > 0) {
            console.log('[VoiceMaster] Ignoring expected stop event');
            this.expectedStops--;
            return;
          }
          
          this.isListening = false;
          if (this.config?.onListeningChange) this.config.onListeningChange(false);
          
          if (this.shouldBeListening && this.shouldRestart && !this.micBusy) {
             this.triggerRestart();
          }
        } else if (state.status === 'started') {
          this.isListening = true;
          if (this.config?.onListeningChange) this.config.onListeningChange(true);
        }
      });
      
      await CapacitorSpeechRecognition.start({
        language: 'en-US',
        partialResults: true,
        popup: false,
      });
      
      this.isListening = true;
      this.consecutiveFailures = 0;
      await pulseHapticLight();
      return true;
    } catch (e) {
      console.error('[VoiceMaster] Failed to start:', e);
      this.lastErrorTime = Date.now();
      this.consecutiveFailures++;
      
      if (this.consecutiveFailures >= VoiceMasterEngine.MAX_CONSECUTIVE_FAILURES) {
        this.micBusy = true;
        this.isListening = false;
        if (this.onMicBusyChange) this.onMicBusyChange(true);
        if (this.onRetryNeeded) this.onRetryNeeded();
        return false;
      }
      
      if (this.shouldBeListening) this.scheduleRestart();
      return false;
    } finally {
      this.isStarting = false; // UNLOCK
    }
  }

  // 6. UPDATE: scheduleRestart to use Gatekeeper
  private scheduleRestart(): void {
     // ... (Keep existing lockout logic) ...
     if (this.restartTimeout) clearTimeout(this.restartTimeout);
     this.restartTimeout = setTimeout(() => {
        if (this.shouldBeListening && !this.micBusy) {
           if (isNative) this.triggerRestart(); // SAFE
           else this.startWeb();
        }
     }, 500);
  }

  // ... (rest of class)
}
Step 2: Remove the "Old Logic" from client/src/pages/game.tsx
You must delete the manual pause/resume calls in the bot move effect.

TypeScript

//

// Inside the useEffect for bot moves (approx line 1180)

          if (voiceOutputEnabled) {
            isTtsSpeaking.current = true;
            
            // DELETE THIS SECTION ----------------------
            // if (voiceInputEnabled) {
            //   await voiceRecognition.pauseLoop();
            // }
            // ------------------------------------------

            const isCheck = gameRef.current.isCheck();
            // ... logic ...
            const spokenMove = moveToSpeech(botMove.move, isCapture, isCheck, isCheckmate);
            
            try {
              await speak(spokenMove); // speak() now handles the mic safely!
            } catch (e) {
              console.error('[Voice] TTS error:', e);
            } finally {
              isTtsSpeaking.current = false;
              
              // DELETE THIS SECTION ----------------------
              // if (voiceInputEnabled) {
              //   await voiceRecognition.resumeLoop();
              // }
              // ------------------------------------------
            }
          }