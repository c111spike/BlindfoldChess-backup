You have found the final "Logic Bomb."

The issue is Premature Resume.

The Diagnosis
Your speak() function is relying on await CapacitorSpeechSynthesis.speak(...) to know when the bot is done talking. Here is the trap: On many Android devices (and plugin versions), that Promise resolves immediately after the text is sent to the OS queue—NOT when the voice actually finishes speaking.

The Crash Sequence:

Code: speak("Queen to d5").

Code: voiceController.onTTSStart() → Mic Pauses (Correct).

Plugin: Sends text to Android OS.

Plugin: Resolves Promise INSTANTLY.

Code: Thinks speech is done. Calls voiceController.onTTSEnd() → Mic Resumes.

Reality: The Bot is just starting to speak "Queen..."

Collision: The Mic tries to start while the TTS is speaking. Android Audio Focus blocks it.

Death: The startNative loop retries 3 times (taking ~600ms). The Bot is still talking (taking ~1.5s). The Mic hits MAX_CONSECUTIVE_FAILURES and permanently dies.

The Fix: Event-Driven Waiting
We must ignore the Promise and instead wait for the specific onEnd event from the TTS engine. This ensures the mic never attempts to restart until the robot is truly silent.

Here is the replaced speak function for client/src/lib/voice.ts.

client/src/lib/voice.ts
Find your export const speak = ... function (likely near the bottom) and completely replace it with this robust version:

TypeScript

//

export const speak = async (text: string): Promise<void> => {
  if (!voiceMaster.config?.voiceOutputEnabled) return;

  // 1. Pause Mic (Locks the state machine)
  voiceController.onTTSStart();

  try {
    if (isNative) {
      // NATIVE: Ignore the Promise, wait for the 'end' EVENT
      await new Promise<void>(async (resolve) => {
        let hasResolved = false;
        
        // FAILSAFE: If the event never fires (rare Android bug), force resume after (Time + Buffer)
        // Calculation: ~150ms per character + 2000ms base buffer
        const timeoutDuration = Math.max(2500, text.length * 150); 
        const timer = setTimeout(() => {
          if (!hasResolved) {
            console.warn('[Voice] TTS Event timeout - forcing resume');
            hasResolved = true;
            resolve();
          }
        }, timeoutDuration);

        // LISTENER: The only source of truth
        let listener: any = null;
        try {
            listener = await CapacitorSpeechSynthesis.addListener('end', () => {
                if (!hasResolved) {
                    console.log('[Voice] TTS End detected via event');
                    clearTimeout(timer);
                    hasResolved = true;
                    if (listener) listener.remove();
                    resolve();
                }
            });
        } catch (setupErr) {
            console.warn('Failed to setup TTS listener', setupErr);
        }

        // SPEAK
        await CapacitorSpeechSynthesis.speak({
          text,
          lang: 'en-US',
          rate: 1.0,
          pitch: 1.0,
          volume: 1.0
        });
        
        // If listener setup failed, we rely on the timer (or the promise if it's truly blocking on this device)
        if (!listener) {
             // Fallback for devices that don't support listeners
             clearTimeout(timer);
             resolve(); 
        }
      });
    } else {
      // WEB: Standard API
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = 1.0; // Faster for training
      
      await new Promise<void>((resolve) => {
        utterance.onend = () => resolve();
        utterance.onerror = () => resolve(); // Always resolve to unblock mic
        window.speechSynthesis.speak(utterance);
      });
    }
  } catch (e) {
    console.error('[Voice] Speak failed:', e);
  } finally {
    // 2. Resume Mic
    // The delay inside onTTSEnd (350ms) + triggerRestart (100ms) = 450ms safety buffer
    // This now runs ONLY after silence is confirmed.
    console.log('[Voice] Speech complete, requesting mic resume...');
    voiceController.onTTSEnd();
  }
};
Why this fixes the "Still Pausing" issue
Before: The code waited 0.01 seconds (Promise resolution), then tried to start the mic while the speaker was blasting audio. Result: Busy Error -> Crash.

After: The code waits ~2.0 seconds (Event Listener), confirms silence, then waits another 350ms (S9+ buffer), then starts the mic. Result: Clean Start.