Hitting 100MB is the standard "pain threshold" for mobile developers. Looking at your breakdown, you aren't suffering from "code bloat"â€”you are suffering from "Universal Binary" bloat.Your APK currently contains four copies of every native library (one for every type of processor: older phones, new phones, emulators, etc.).Here is exactly how to slash that size by 40% to 50% immediately.1. The "Quick Fix" for your Test APK (ABI Filters)Since you are testing on a physical Android phone, you almost certainly only need the arm64-v8a architecture. You are currently carrying dead weight for x86 (emulators) and 32-bit ARM (ancient phones).The Fix:Open your android/app/build.gradle file. Look for the defaultConfig block and add an ndk block inside it.Gradleandroid {
    defaultConfig {
        // ... existing config ...
        
        ndk {
            // ONLY include the library for modern Android phones
            // This strips out x86, x86_64, and armeabi-v7a
            abiFilters "arm64-v8a"
        }
    }
}
The Result:Vosk Libs: 37MB $\rightarrow$ ~9MBSQLCipher: 19MB $\rightarrow$ ~5MBTotal Savings: ~42MBNote: If you need to test on the Android Studio Emulator later, you will need to add "x86_64" back to that list. But for physical device testing, arm64-v8a is king.2. The "Production Fix" (Android App Bundles)When you are ready to upload to the Play Store, you don't need to worry about this limit as much.Instead of building an .apk, you will build an .aab (Android App Bundle).Command: cd android && ./gradlew bundleReleaseHow it works: You upload the massive 100MB+ bundle to Google. When a user downloads your app, Google dynamically generates an APK specifically for their phone.A user with a Pixel 7 will download only the ARM64 libraries and only the high-res icons.Your download size on the store will likely be ~60MB, well below the danger zone.3. Can we shrink Vosk (~70MB)?The vosk-model-small-en-us-0.15 is about as small as it gets for decent offline accuracy (~50MB zipped, ~70MB unzipped).Don't delete ivector: It helps with speaker adaptation.Don't delete Gr.fst: That is the grammar graph.Optimization: Since you are using a strictly restricted grammar (your JSON list of chess words), there is a theoretical advanced technique called "Graph Compilation" where you replace the massive HCLr.fst with a tiny one tailored only to your words. However, this requires complex Kaldi knowledge and compilation tools.Verdict: For now, stick with the 70MB model. The ABI Filter (Step 1) is the low-hanging fruit that solves your immediate problem.