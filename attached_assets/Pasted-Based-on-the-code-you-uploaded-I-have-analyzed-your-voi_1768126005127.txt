Based on the code you uploaded, I have analyzed your voice.ts file. You have built a very sophisticated "Gold Standard" architecture to handle the notorious Android Speech Recognition lifecycle (especially for the S9+), but I found the specific "logic bomb" that is likely causing your 27 iterations of failure.

The core issue is a Race Condition in your Restart Logic.

You have two competing restart mechanisms that are not synchronized, which causes "Double Start" calls. Android's SpeechRecognizer is extremely fragile; if you call start() while it is initializing or shutting down, it throws a "Client Busy" error, which triggers your error handler, which schedules another restart, creating a death spiral.

The Conflict
Your startNative() function is the choke point. It is being called from two "unprotected" directions simultaneously:

The Event Loop (triggerRestart): When the native listeningState changes to stopped, you call triggerRestart(). This function correctly uses a mutex (this.restartPromise) and a 50ms buffer to serialize restarts. This part is good.

The Error Loop (scheduleRestart): When startNative() fails (e.g., occasional permission check delay or temporary busy signal), it enters the catch block and calls scheduleRestart(). Critically, scheduleRestart() uses setTimeout to call startNative() directly, completely bypassing your restartPromise mutex.

The Crash Scenario:

triggerRestart activates. It stops the mic and waits 50ms.

During this 50ms window, or just as it finishes, a lingering error or state change triggers scheduleRestart.

triggerRestart calls startNative.

scheduleRestart's timer fires and also calls startNative.

Collision: Both remove the listeners (fighting over the handle) and both call CapacitorSpeechRecognition.start().

The second call fails immediately because the first one is running. This increments consecutiveFailures.

The loop repeats until MAX_CONSECUTIVE_FAILURES is hit, and the mic permanently dies (Zombie state).

The Fix
You need to route ALL automatic restarts through a single "Gatekeeper" that respects the mutex. You should modify scheduleRestart to use triggerRestart instead of calling startNative directly, or wrap startNative to ensure it never runs concurrently.

Here is the recommended fix for client/src/lib/voice.ts:

1. Modify scheduleRestart to respect the Mutex
Change scheduleRestart to call triggerRestart() (which is safe) instead of startNative() (which is unsafe).

TypeScript

// In client/src/lib/voice.ts inside VoiceMasterEngine class

private scheduleRestart(): void {
  // ... existing check for lockout ...
  const timeSinceLastError = Date.now() - this.lastErrorTime;
  if (timeSinceLastError < 3000 && this.lastErrorTime > 0) {
     // ... logic is fine ...
  }

  if (this.micBusy) return;

  if (this.restartTimeout) clearTimeout(this.restartTimeout);

  this.restartTimeout = setTimeout(() => { // Removed 'async'
    if (this.shouldBeListening && !this.micBusy) {
      console.log('[VoiceMaster] Scheduled restart firing via Gatekeeper');
      
      // FIX: Do not call startNative() directly. 
      // Call triggerRestart() so it respects the restartPromise mutex.
      this.triggerRestart(); 
    }
  }, 500);
}
2. Guard startNative against itself
Even with the fix above, start() (from the UI) can still collide with a background restart. Add a running guard to startNative.

TypeScript

// Add a new flag to the class
private isStarting: boolean = false;

private async startNative(): Promise<boolean> {
  // 1. GLOBAL GUARD: If we are already in the middle of a start sequence, abort.
  if (this.isStarting) {
      console.log('[VoiceMaster] startNative blocked: Already starting');
      return false;
  }
  
  if (this.micBusy) {
    console.log('[VoiceMaster] Mic is busy, not starting');
    return false;
  }

  this.isStarting = true; // Lock

  try {
    // ... existing start logic ...
    // ... await CapacitorSpeechRecognition.start(...) ...
    
    this.isListening = true;
    this.consecutiveFailures = 0;
    // ...
    return true;
  } catch (e) {
    // ... existing error handling ...
    return false;
  } finally {
    this.isStarting = false; // Unlock immediately after attempt finishes
  }
}
Summary of Changes
Route scheduleRestart -> triggerRestart: This forces errors to wait in line with the standard loop, preventing the error handler from crashing the event handler.

Lock startNative: This prevents the UI (User clicking "Start") from crashing the background loop if they happen at the exact same millisecond.

This should stabilize the "2-headed beast" that is currently killing your S9+ mic connection.