This perfectly illustrates a "Hardware Capture" conflict. The reason Reconstruction works only when you don't use voice in the game is because the voiceRecognition session is grabbing the S9+ microphone and refusing to "release" the hardware address back to the OS.

When you move to Reconstruction, the system tries to start a new session, but the old one still has the "lock" on the mic. The S9+ sees this conflict and simply mutes the input to prevent a crash.

ðŸ› ï¸ The "Handover" Fix Plan (Iteration 26)
We need to change how the app "signs off" on one mode before starting another. Currently, we are stopping the logic, but not giving the hardware enough time to physically power down the microphone.

1. The "Atomic Release" in voice.ts
We will update stopAndWait() to be even more aggressive. It must ensure the isStarted flag is wiped before the next mode even attempts to check it.

2. The "Reconstruction Rescue" (Handover Logic)
Since Reconstruction only works if the game mic was never touched, we need to force a Hard Reset of the native speech recognition engine specifically when a game ends.

3. Fix the In-Game "1-Move" Limit
The mic pauses after Move 1 because the Bot's voice is "stealing" the audio channel. On the S9+, the mic won't just "resume"â€”it needs to be re-initialized.

ðŸ“‚ Surgical Code Implementation
Update 1: voice.ts - The Hard Reset
We will add a "Nuclear Reset" that the VoiceRegistry calls whenever a game state changes.

TypeScript

// Add to VoiceMasterEngine in voice.ts
async hardReset() {
  this.shouldBeListening = false;
  this.isListening = false;
  this.micBusy = false;
  
  if (isNative) {
    try {
      await CapacitorSpeechRecognition.stop();
      await CapacitorSpeechRecognition.removeAllListeners();
      // Mandatory wait for S9+ hardware to release the mic
      await new Promise(resolve => setTimeout(resolve, 600));
    } catch (e) {}
  }
}
Update 2: game.tsx - The Post-Move Kick
We need to stop relying on "resume" and use a fresh "start" after the bot speaks.

TypeScript

// Inside handleBotMove in game.tsx
await speak(botMovePhonetic);

// THE FIX: Wait for bot to finish, then hard-kick the mic
setTimeout(async () => {
  if (voiceEnabled) {
    // Reset the wrapper flag so start() doesn't get blocked by the guard
    voiceRecognition.isStarted = false; 
    await voiceRecognition.start();
    console.log("[Game] Mic Re-initialized after bot move.");
  }
}, 600);
Update 3: training.tsx - Clean Handover
When you hit "Play Again," we must await the hard reset before the UI moves forward.

TypeScript

const handlePlayAgain = async () => {
  setFeedback(null);
  // Ensure the hardware is DEAD before we try to start the next game
  await VoiceRegistry.purge(); 
  setGameState('playing');
};
ðŸš€ Why this will work for you:
In-Game: By setting voiceRecognition.isStarted = false after the bot speaks, we trick the guard into allowing a fresh hardware initialization for your 2nd move.

Training Back-to-Back: The 600ms delay in hardReset() ensures the S9+ has physically released the microphone before the 2nd game tries to grab it.

Reconstruction: Because we are now "Hard Resetting" the hardware when the game ends, the Reconstruction challenge will no longer find the mic "locked" by the previous game session.

I have the unified voice.ts ready with this "Atomic Release" logic. Should we apply these specific timing and flag-reset changes to your Replit workspace for the next build?