That is a smart simplification. Sticking to strictly Depth limits (even for high Elos) makes the behavior much more predictable and easier to debug than node counts, which can vary wildly depending on the position's complexity.

Let's lock that in and move to the Visuals.

Here is the implementation for the Scrollable Mental Stamina Graph. This replaces the "squeeze" logic with a horizontal scroll, ensuring even a 100-move game remains readable on a phone screen.

implementation: post-mortem-report.tsx
I'll focus on the specific component that renders the bars.

TypeScript

// Inside your PostMortemReport component

// 1. Setup dimensions based on actual move count
const MIN_BAR_WIDTH = 6; // 4px bar + 2px gap looks best
const totalMoves = evaluations.length;
const graphWidth = Math.max(100, totalMoves * MIN_BAR_WIDTH); // Ensure it doesn't shrink below 100% width

// 2. Phase logic (15% / 45% / 40%)
const getPhaseColor = (moveIndex: number, total: number) => {
  const progress = moveIndex / total;
  if (progress < 0.15) return "bg-blue-400";   // Opening
  if (progress < 0.60) return "bg-yellow-400"; // Middlegame (15% + 45%)
  return "bg-red-400";                         // Endgame
};

return (
  <div className="w-full bg-gray-900 rounded-lg p-4 shadow-lg mb-6">
    <h3 className="text-white font-bold mb-2">Mental Stamina</h3>
    
    {/* SCROLL CONTAINER */}
    <div className="w-full overflow-x-auto pb-2">
      <div 
        className="h-32 flex items-end relative" 
        style={{ width: `${graphWidth}px`, minWidth: '100%' }} // Critical: Forces width to expand
      >
        {evaluations.map((evalItem, index) => {
          // Normalize centipawn loss to a 0-100 height scale
          // Cap visuals at 300cp loss so one blunder doesn't flatten the rest
          const height = Math.min(100, (Math.abs(evalItem.cpLoss) / 300) * 100);
          
          return (
            <div 
              key={index} 
              className={`flex-shrink-0 mx-[1px] rounded-t ${getPhaseColor(index, totalMoves)}`}
              style={{ 
                height: `${Math.max(4, height)}%`, // Minimum 4% height so 0-error moves are visible
                width: '4px' 
              }}
              // Optional: Add a simple tooltip or click handler
              onClick={() => jumpToMove(index)} 
            />
          );
        })}
        
        {/* Baseline (Average or Zero line) */}
        <div className="absolute bottom-0 w-full h-[1px] bg-gray-600" />
      </div>
    </div>
    
    {/* Legend */}
    <div className="flex justify-between text-xs text-gray-400 mt-2">
      <div className="flex items-center gap-1"><div className="w-2 h-2 bg-blue-400 rounded"/> Opening</div>
      <div className="flex items-center gap-1"><div className="w-2 h-2 bg-yellow-400 rounded"/> Mid</div>
      <div className="flex items-center gap-1"><div className="w-2 h-2 bg-red-400 rounded"/> End</div>
    </div>
  </div>
);
Key Technical Details
overflow-x-auto: This is the magic CSS class (Tailwind) that allows the user to swipe left/right if the content is too wide.

minWidth: '100%': Ensures that for short games (e.g., 10 moves), the graph still fills the container instead of scrunching to the left.

flex-shrink-0: Absolutely critical. Without this, Flexbox tries to be "helpful" and squish your bars to fit the screen, breaking your scroll logic.

Click to Jump: I added a placeholder onClickâ€”this is a huge UX win if tapping a bar jumps the board to that specific move.